Ok, this challenge is called ropmev2, so it seems we'll be doing a rop attack.
Let's verify,
rabin2 -I output shows that the NX bit is set, so the stack is not executable, rop it is

After analysis, the code shows that in main:

1) It sets up an output buffer, into LINEBUFFER mode. This means, data is not outputted
until a \n is encountered. This is important when leaking data
2) It printfs "Please don't hack me"
3) It allocates 0xd0(208) bytes on the stack
4) It reads 500 bytes onto the stack, overwriting the RIP
5) Then it checks if the first bit of the buffer is "DEBUG\n"
6) If it is, it prints "I don't know what this is ", followed by an address
7) The address is rsi (See 0x004011da), and holds the address of the input buffer on the stack
   This should contain (DEBUG\n)
8) Then it runs main again and the thing starts again
9) The way to get out of this, is to have something in the input that does not startwith INPUT\n
10) When you play with it, you'll notice the difference in starts of the buffers is E0(224) bytes
So the stack layout is:


I | Type | Size
2 | BUF  | 208
2 | RBP  | 8  <-- Pointing to the stack frame of the first iteration of main
2 | RIP  | 8  <-- Pointing to 0x004011f8 (The one in main, after the call of main)
1 | BUF  | 208
1 | RBP  | 8 < -- Containing the stack frame of first main's caller
1 | RIP  | 8 < -- Pointing to somewhere where the first main() was called

The sizes for one iteration add up to 224 bytes, so far so good.
It seems we can control the executionflow of the program, by overwriting the RIP in the second
iteration.

11) Ok, so first we need to fill the first buffer. It really can only be DEBUG\n, because anything else just fails. It uses the read function, which reads n bytes, or until EOF. Anything that is input, including null bytes, or newline characters, is read as is and ultimately fed to strcmp. If it's anything more than DEBUG\n, the function will fall through. So, we need to send two inputs. How do we do this? Well, we use named pipes. See below:

Use this syntax: cat <( echo "DEBUG" ) <( echo "DEBUG") | ./ropmev2

This fills the first buffer with DEBUG\n, causing it the loop back to main, and to fill the second one as well, also causing it to loop to main. We don't need the second loop, but just for testing purposes this is done now.

Note:
Before an iteration of main exits, and returns to a pointer of our choice,
it puts the address of our buffer in rdi, and executes label.process_input.

Note:
rdi is per the x86_64 calling convention, the first argument of any function.
We could theoretically, put our payload on the buffer, and the make the function jump to
printf to display it.

Note:
We can control EBP as well, so before a function returns, we can point its frame pointer 
to a location of our choosing. Might come in handy.

The way a ROP attack works is that you'll fill a buffer with data that can be popped
into parameters(reg) and return addresses.

The command ROPgadget --binary <bin> -- all will give a nice overview of useful operations and the
addresses where they are located. Aka gadgets.

Ideally, we would use a command like execve or system to execute shellcode, but analysis reveils
there are no entry points for these functions (The program does not use them). Also, since ASLR is enabled locally and might be remotely, we can't jump to these functions without some kind of bypass.
It seems we'll have to syscall our way into a shell.

See: execve("/bin/sh", *"/bin/sh", (char **)NULL);
     RAX     RDI         RSI                RDX    

So, to open a new process, we need the following:
1) A gadget that does a syscall
2) A gadget that can set, or increase rax to select the syscall
3) Somthing that hanles RDI
4) Somethin that handls RSI
5) Something that handles RDX

Let's find a syscall gadget:

0x0000000000401168 : syscall
0x0000000000401162 : pop rax ; ret
0x000000000040142b : pop rdi ; ret
0x0000000000401429 : pop rsi ; pop r15 ; ret
0x0000000000401164 : pop rdx ; pop r13 ; ret

Ok, we got some useful stuff, but further analysis indicates:
1) There is not call to system or execve
2) ROPping your way to a syscall to get a shell doesn't look feasible
3) ASLR might be enabled, so a static ret-to-system won't work

It seems we'll have to bypass ASLR
Ok, let's fire up the debugger and determine the address of printf and system, so we can calculate
the difference.

633   0x00054b40 0x7f6a319a4b40 GLOBAL FUNC   200      printf
1421  0x00046ff0 0x7f6a31996ff0 WEAK   FUNC   45       system

FMI, let's find of the GOT table's printf entry indeed jumps to 0x7f6a319a4b40 Always be checking and double checking... Asi se apprende .. and it does!

So the offset from printf = 0x7f6a319a4b40 - 0x7f6a31996ff0 = db50

So now we have to figure out a way to leak the address of printf(), so we can jump to system()


